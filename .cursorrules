# ======================================================

# REKON.GG — Cursor Rules (Final, Folder-Aware Version)

# ======================================================

# These rules apply to ALL code produced inside this repo.

# ======================================================

# 1. MONOREPO STRUCTURE (DO NOT BREAK)

# ======================================================

The repository structure is fixed and must ALWAYS remain:

rekon/
├── apps/
│ ├── web/ # Next.js 16 frontend
│ └── api/ # Hono backend
├── packages/
│ ├── types/ # Shared types and domain models
│ ├── utils/ # Helper functions, PnL calc, formatting
│ ├── config/ # Runtime constants, env, settings
│ └── ui/ # shadcn/ui-based design system
├── turbo.json
├── pnpm-workspace.yaml
├── tsconfig.json
└── package.json

RULES:

- Never modify folder layout unless asked.
- Never create new top-level folders.
- All new code MUST live under /apps or /packages.
- Imports must follow alias style:
  @rekon/types
  @rekon/utils
  @rekon/config
  @rekon/ui

# ======================================================

# 2. FRONTEND RULES (Next.js 16 in /apps/web)

# ======================================================

- Must use **App Router** (already in /src/app).
- Use **Server Components** by default.
- Use **Client Components** ONLY when necessary:
  - charts
  - websockets
  - interactive inputs
  - animations

Frontend structure must be:

apps/web/src/
app/ -> routes
components/ -> generic UI components
modules/ -> market, trade, portfolio, esports modules
hooks/
lib/
styles/
providers/

Use:

- shadcn/ui for UI primitives
- Tailwind CSS
- TypeScript strict mode
- No inline complex logic; push it into modules.

Prohibition:

- No Redux / Zustand / Jotai unless explicitly allowed.
- No mixing backend logic inside frontend.
- No long unstructured components.

# ======================================================

# 3. BACKEND RULES (Hono API in /apps/api)

# ======================================================

Backend must remain minimal, typed, and modular.

apps/api/src/
index.ts
routes/
controllers/
services/
adapters/ -> Polymarket & external APIs
db/
utils/
types/

Backend conventions:

- Use Hono.
- Use Zod for ALL validation.
- Controllers = routing logic only.
- Services = business logic.
- Adapters = external dependency wrappers.
- utils = pure helper functions.

Error Handling:

- NEVER use try-catch blocks in controllers.
- Use Hono's global error handler (app.onError) instead.
- Let errors bubble up from services/adapters to the global handler.
- Global error handler should handle:
  - HTTPException (expected errors with status codes)
  - ZodError (validation errors → 400)
  - Unexpected errors (→ 500 with logging)
- Controllers should focus on business logic, not error handling.
- Only use try-catch for specific local cleanup operations (e.g., finally blocks).

Polymarket Logic:

- Must ALWAYS live in /apps/api/src/adapters/polymarket.
- Never call Polymarket directly from frontend.

# ======================================================

# 4. DOMAIN RULES (Prediction Market Trading Terminal)

# ======================================================

This project is a **Pro Trading Terminal for Esports Prediction Markets**.

Domain logic MUST be separated into modules in either:

- /packages/types
- /packages/utils
- /packages/config
- /apps/api/services

Core Rekon domain modules:
MarketModule
OrderModule
PriceFeedModule
PortfolioModule
PnLModule
ChartModule
EsportsFeedModule
UserPositionModule

Rules:

- Domain logic must be deterministic and testable.
- No UI logic inside domain modules.
- No API calls inside domain modules.

# ======================================================

# 5. PACKAGES RULES

# ======================================================

/packages/types

- Define all shared TypeScript interfaces, enums, models.
- Ensure strict typing for:
  Market
  Outcome
  Order
  Trade
  Position
  PnL
  EsportsEvent

/packages/utils

- All formatting (dates, numbers)
- PnL calculator
- ROI functions
- Lightweight chart data transform
- Pure utilities only (no side effects)

/packages/config

- All runtime constants
- Polymarket endpoints
- Esports feeds
- Trading thresholds, precision, rounding

/packages/ui

- Reusable UI components
- Re-exports of shadcn/ui
- Tailwind utilities

# ======================================================

# 6. POLYMARKET BUILDER INTEGRATION

# ======================================================

ALL Polymarket logic belongs under:

apps/api/src/adapters/polymarket/

This includes:

- order placement
- order cancellation
- fetching markets
- fetching orderbooks
- user positions
- liquidity snapshots

Rules:

- Never leak raw Polymarket response shapes to frontend.
- Always map external types → @rekon/types models.
- Must support plugging in additional venues later.

# ======================================================

# 7. CODING STANDARDS & NAMING

# ======================================================

- Use TypeScript strict mode.
- Use named exports everywhere.
- Never use default exports.
- Use async/await, avoid .then chains.
- Avoid any `any` type.
- Use PascalCase for components & domain models.
- Use camelCase for functions & variables.
- Use kebab-case for filenames.

Comments:

- Only comment non-obvious logic.
- Do not generate excessive comment blocks.

# ======================================================

# 8. WEBSOCKETS & REAL-TIME LOGIC

# ======================================================

Rules:

- All live market data must use websocket subscriptions.
- Implement websocket abstraction in /packages/utils/ws/.
- Frontend should consume data via:
  usePriceFeed()
  useMarketFeed()
  etc.
- No direct websocket logic inside React components.

# ======================================================

# 9. OUTPUT RULES FOR CURSOR

# ======================================================

Whenever code is generated:

- Always produce COMPLETE files.
- Always place files in correct folder.
- Never create empty or placeholder files.
- Never break imports or structure.
- Never mix frontend and backend code.
- Always follow design choices above.

# ======================================================

# 10. VISUAL STYLE (ESPORTS TERMINAL)

# ======================================================

UI should always reflect:

- dark mode
- neon accents (blue/purple/cyan)
- terminal-like grid layout
- dense but readable charts
- pro-trading feel

Charts:

- Use Lightweight-Charts or Recharts.
- No huge libraries. Keep fast & lightweight.

# ======================================================

# 11. POST-CHANGE VERIFICATION

# ======================================================

After ANY code changes, ALWAYS run type checking and linting:

- Run `pnpm type-check` or `pnpm build` to verify no TypeScript errors.
- Run `pnpm lint` to check for linting issues.
- Fix ALL errors before considering the task complete.
- Never leave the codebase in a broken state.

Verification Commands:

```bash
pnpm type-check    # Check TypeScript types across all packages
pnpm lint          # Run ESLint across the monorepo
pnpm build         # Full build to catch all errors
```

Rules:

- If type errors are introduced, fix them immediately.
- If linting errors are introduced, fix them immediately.
- Do not proceed to new tasks until the build passes.
- Always verify imports resolve correctly after refactoring.

# ======================================================

# 12. MARKET FILTERING & CONSISTENCY

# ======================================================

Market Type Filtering Rules:

When working with markets that have multiple subevents (e.g., Dota 2 matches):

Primary Market Types (SHOW):

- "moneyline" - Match/series winner
- "totals" - Over/Under markets
- "child_moneyline" - Individual game/map winners (Game 1, 2, 3)

Filtered Out Market Types (HIDE):

- "exact_score" - Too specific, low liquidity
- "player_prop" - Niche player markets
- "handicap" - Spread markets
- "special" - Derivative/special bets

Implementation Locations:

Backend:

- apps/api/src/services/markets.ts
  - filterRelevantMarketTypes() function
  - Applied in getMarketsByEventSlug()

Frontend:

- apps/web/src/lib/market-filters.ts (shared utility)
  - filterRelevantMarketTypes() - Filter markets
  - hasSubevents() - Detect multi-market events
  - getRelevantMarketTypeCount() - Count market types
- apps/web/src/modules/markets/market-detail-page.tsx
  - Uses shared utility for subevent filtering
- apps/web/src/modules/markets/market-card.tsx
  - Shows "Multiple markets →" indicator for events with subevents

Key Concepts:

Outcomes vs Market Types:

- OUTCOMES = Results within ONE market (e.g., ["Team A", "Team B"] = 2 outcomes)
- MARKET TYPES = Different markets for same event (e.g., Moneyline, Game 1, O/U = 3 types)

Example:

- API returns: 11 market types (Moneyline + Games + Exact scores + Props)
- UI displays: 4 market types (Moneyline, Game 1, Game 2, O/U)
- Match Polymarket's UI behavior

Rules:

- Always filter markets to show only primary types
- Keep backend and frontend filtering logic in sync
- Use shared utilities to avoid code duplication
- Market cards must indicate when multiple market types exist
- Detail page shows filtered subevent buttons
- Markets with eventSlug are considered esports markets (subevents like O/U, Game 1, etc.)
  - This prevents "Not an Esports Market" error for totals/O/U markets
  - Check: hasEventSlug || hasDetectedGame || hasEsportsCategory || hasEsportsKeywords

# ======================================================

# END OF RULES

# ======================================================
